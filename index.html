<!-- Mobile QA checklist: verify no horizontal scroll at 390x844, 360x740, 844x390; current row + palette usable; submit visible; history accessible. -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Logic — Board Interface</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Trebuchet MS", "Segoe UI", Tahoma, sans-serif;
        background-color: #e6dcc2;
        color: #3d3526;
        --safe-left: env(safe-area-inset-left);
        --safe-right: env(safe-area-inset-right);
        --safe-top: env(safe-area-inset-top);
        --safe-bottom: env(safe-area-inset-bottom);
        --socket-size: 58px;
        --socket-gap: 12px;
        --feedback-size: 18px;
        --feedback-gap: 6px;
        --peg-size: 42px;
        --code-length: 5;
        --feedback-columns: 3;
        --feedback-rows: 2;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: calc(24px + var(--safe-top)) calc(24px + var(--safe-right))
          calc(24px + var(--safe-bottom)) calc(24px + var(--safe-left));
        background: radial-gradient(circle at top, #efe5c8 0%, #e3d4b3 60%, #d8c6a1 100%);
      }

      .game-shell {
        display: flex;
        justify-content: center;
        max-width: 100%;
      }

      .board-frame {
        padding: 24px;
        background: linear-gradient(180deg, #f2e6c8 0%, #e3d4b3 100%);
        border-radius: 28px;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.8),
          inset 0 -6px 12px rgba(117, 96, 62, 0.35),
          0 24px 40px rgba(72, 56, 32, 0.25);
        width: fit-content;
        max-width: 1100px;
        margin: 0 auto;
      }

      .board {
        min-width: 920px;
        width: fit-content;
        max-width: 100%;
        display: grid;
        grid-template-columns: minmax(540px, 1fr) minmax(260px, 320px);
        gap: 24px;
        background: #e8d7b8;
        padding: 24px;
        border-radius: 24px;
        box-shadow: inset 0 0 0 2px rgba(108, 84, 47, 0.25),
          inset 0 20px 30px rgba(255, 255, 255, 0.3);
      }

      .board-playfield {
        transform: scale(var(--board-scale, 1));
        transform-origin: top center;
      }

      .secret-row {
        position: relative;
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 24px;
        padding: 16px 20px;
        border-radius: 20px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.4), rgba(214, 190, 148, 0.6));
        box-shadow: inset 0 2px 6px rgba(92, 72, 40, 0.35);
      }

      .secret-label {
        font-weight: 700;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-size: 0.8rem;
      }

      .secret-sockets {
        display: grid;
        grid-template-columns: repeat(var(--code-length), calc(var(--socket-size) + 6px));
        gap: 14px;
      }

      .secret-row.revealed .secret-cover {
        transform: translateY(-120%);
        opacity: 0;
      }

      .secret-cover {
        position: absolute;
        inset: 10px 20px 10px 140px;
        background: linear-gradient(180deg, #c6b18a 0%, #b2996a 100%);
        border-radius: 18px;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.4),
          inset 0 -6px 10px rgba(80, 63, 34, 0.4);
        transition: transform 0.6s ease, opacity 0.6s ease;
        pointer-events: none;
      }

      .attempts-area {
        display: grid;
        grid-template-columns: 1fr 40px;
        gap: 16px;
      }

      .attempts-grid {
        display: grid;
        gap: 12px;
      }

      .attempt-row {
        display: grid;
        grid-template-columns: 1fr 130px;
        align-items: center;
        padding: 10px 16px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.25);
        box-shadow: inset 0 1px 3px rgba(94, 73, 43, 0.25);
        position: relative;
      }

      .attempt-row.current {
        box-shadow: 0 0 0 2px rgba(112, 84, 45, 0.6),
          inset 0 2px 6px rgba(94, 73, 43, 0.35);
      }

      .guess-sockets {
        display: grid;
        grid-template-columns: repeat(var(--code-length), var(--socket-size));
        gap: var(--socket-gap);
      }

      .feedback-sockets {
        display: grid;
        grid-template-columns: repeat(var(--feedback-columns), var(--feedback-size));
        grid-template-rows: repeat(var(--feedback-rows), var(--feedback-size));
        gap: var(--feedback-gap);
        justify-content: center;
      }

      .row-numbers {
        display: grid;
        grid-template-rows: repeat(var(--max-attempts, 12), 1fr);
        gap: 12px;
        align-content: start;
        padding-top: 10px;
      }

      .row-number {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 10px;
        font-weight: 700;
        color: #5a4a2f;
        background: rgba(255, 255, 255, 0.4);
        box-shadow: inset 0 1px 3px rgba(94, 73, 43, 0.2);
      }

      .socket {
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #f7f0df 0%, #e2d1af 55%, #c1a57a 100%);
        box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.6),
          inset -4px -4px 6px rgba(90, 67, 36, 0.45);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .socket.large {
        width: var(--socket-size);
        height: var(--socket-size);
      }

      .socket.small {
        width: var(--feedback-size);
        height: var(--feedback-size);
      }

      .socket.interactive {
        cursor: pointer;
      }

      .socket.interactive:focus-visible {
        outline: 2px solid #7f5c2d;
        outline-offset: 3px;
      }

      .socket.interactive.ready {
        box-shadow: 0 0 0 3px rgba(127, 92, 45, 0.4),
          inset 2px 2px 4px rgba(255, 255, 255, 0.6),
          inset -4px -4px 6px rgba(90, 67, 36, 0.45);
      }

      .peg {
        border-radius: 50%;
        box-shadow: inset -2px -2px 4px rgba(0, 0, 0, 0.3),
          inset 2px 2px 4px rgba(255, 255, 255, 0.4);
      }

      .peg.large {
        width: var(--peg-size);
        height: var(--peg-size);
      }

      .peg.small {
        width: calc(var(--feedback-size) - 6px);
        height: calc(var(--feedback-size) - 6px);
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      .peg.black {
        background: #1b1a17;
      }

      .peg.white {
        background: #f7f5f0;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .game-config {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .game-type-picker {
        position: relative;
      }

      .game-type-trigger {
        border: 1px solid rgba(90, 67, 36, 0.35);
        border-radius: 12px;
        padding: 10px 12px;
        font-weight: 700;
        background: rgba(255, 255, 255, 0.7);
        color: #4a3b26;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .game-type-trigger:focus-visible {
        outline: 2px solid #7f5c2d;
        outline-offset: 2px;
      }

      .game-type-options {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        left: auto;
        margin: 0;
        padding: 6px;
        list-style: none;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 14px;
        border: 1px solid rgba(90, 67, 36, 0.35);
        box-shadow: 0 12px 20px rgba(80, 63, 34, 0.25);
        display: none;
        min-width: 220px;
        max-width: calc(100vw - 24px);
        z-index: 20;
      }

      .game-type-options[aria-hidden="false"] {
        display: grid;
        gap: 4px;
      }

      .game-type-option {
        border: none;
        background: transparent;
        padding: 8px 10px;
        border-radius: 10px;
        text-align: left;
        font-weight: 600;
        color: #4a3b26;
        cursor: pointer;
      }

      .game-type-option[aria-selected="true"] {
        background: rgba(127, 92, 45, 0.18);
      }

      .game-type-option:focus-visible {
        outline: 2px solid #7f5c2d;
        outline-offset: 2px;
      }

      .status-plaques {
        display: grid;
        gap: 10px;
      }

      .plaque {
        padding: 10px 14px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.5);
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.8),
          inset 0 -3px 6px rgba(92, 72, 40, 0.25);
        font-weight: 700;
      }

      .tray {
        padding: 14px 16px;
        border-radius: 18px;
        background: linear-gradient(180deg, #ead8b6 0%, #d7c29a 100%);
        box-shadow: inset 0 2px 6px rgba(86, 66, 37, 0.3);
      }

      .tray-label {
        font-weight: 700;
        text-transform: uppercase;
        font-size: 0.75rem;
        margin-bottom: 10px;
        letter-spacing: 0.08em;
      }

      .palette {
        display: grid;
        grid-template-columns: repeat(var(--palette-columns, 4), 1fr);
        gap: 12px;
      }

      .tray-peg {
        border: none;
        background: transparent;
        cursor: pointer;
        padding: 8px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 0 2px rgba(105, 82, 47, 0.3);
      }

      .tray-peg.selected {
        box-shadow: 0 0 0 3px #7f5c2d;
      }

      .tray-peg:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .board-controls {
        display: grid;
        gap: 10px;
      }

      .board-controls button:not(.icon-button) {
        padding: 12px 16px;
        border-radius: 14px;
        border: none;
        font-weight: 700;
        cursor: pointer;
        background: #7f5c2d;
        color: #fef7e6;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.35),
          inset 0 -3px 5px rgba(57, 41, 19, 0.5);
      }

      .board-controls button.secondary {
        background: #d8c09a;
        color: #4a3b26;
      }

      .board-controls button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .board-hint {
        font-size: 0.85rem;
        color: #5d503a;
        line-height: 1.4;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .desktop-layout {
        flex: 0 1 auto;
      }

      .mobile-layout {
        display: none;
        width: min(100%, 560px);
        margin: 0 auto;
        padding: 16px;
        border-radius: 24px;
        background: linear-gradient(180deg, rgba(242, 230, 200, 0.8), rgba(224, 210, 180, 0.9));
        box-shadow: inset 0 2px 6px rgba(86, 66, 37, 0.3),
          0 12px 24px rgba(72, 56, 32, 0.18);
      }

      .mobile-status {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 14px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.6);
        box-shadow: inset 0 1px 3px rgba(94, 73, 43, 0.25);
      }

      .mobile-status-text {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 700;
        white-space: nowrap;
      }

      .mobile-new-game {
        border: none;
        border-radius: 14px;
        padding: 10px 14px;
        font-weight: 700;
        background: #7f5c2d;
        color: #fef7e6;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.35),
          inset 0 -3px 5px rgba(57, 41, 19, 0.5);
        cursor: pointer;
      }

      .mobile-controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
      }

      .mobile-section-title {
        font-weight: 700;
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        margin-bottom: 10px;
      }

      .mobile-current,
      .mobile-history,
      .mobile-palette {
        margin-top: 12px;
      }

      .mobile-current-row {
        display: grid;
        gap: 8px;
      }

      .mobile-history-list {
        display: grid;
        gap: 8px;
        max-height: 400px;
        overflow-y: auto;
        padding-right: 2px;
      }

      .mobile-layout {
        --mh-token: 34px;
        --mh-gap: 8px;
      }

      .m-history__row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: inset 0 1px 3px rgba(94, 73, 43, 0.2);
        max-width: 100%;
      }

      .m-history__row--current {
        box-shadow: 0 0 0 2px rgba(112, 84, 45, 0.45),
          inset 0 1px 3px rgba(94, 73, 43, 0.25);
      }

      .m-history__guess {
        display: flex;
        flex-wrap: nowrap;
        gap: var(--mh-gap);
        align-items: center;
        flex: 1 1 auto;
        min-width: 0;
      }

      /* History tokens intentionally avoid socket styling for readability. */
      .m-history__token {
        width: var(--mh-token);
        height: var(--mh-token);
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.4);
        border: 1px solid rgba(0, 0, 0, 0.15);
        box-shadow: 0 1px 2px rgba(58, 44, 24, 0.2);
        flex: 0 0 auto;
      }

      .m-history__token--empty {
        background: rgba(255, 255, 255, 0.5);
      }

      .m-history__token--interactive {
        cursor: pointer;
      }

      .m-history__token--interactive:focus-visible {
        outline: 2px solid #7f5c2d;
        outline-offset: 3px;
      }

      .m-history__token--ready {
        box-shadow: 0 0 0 2px rgba(127, 92, 45, 0.35), 0 1px 2px rgba(58, 44, 24, 0.2);
      }

      .m-history__feedback {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        align-items: center;
        flex: 0 0 auto;
      }

      .m-history__feedback--placeholder {
        min-width: 34px;
        min-height: 14px;
      }

      .m-history__peg {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        box-shadow: inset -1px -1px 2px rgba(0, 0, 0, 0.25),
          inset 1px 1px 2px rgba(255, 255, 255, 0.35);
      }

      .m-history__peg--black {
        background: #1b1a17;
      }

      .m-history__peg--white {
        background: #f7f5f0;
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      .mobile-secret {
        display: none;
        margin-top: 16px;
        padding: 12px 14px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.5);
        box-shadow: inset 0 1px 3px rgba(94, 73, 43, 0.25);
      }

      .mobile-secret.revealed {
        display: block;
      }

      .mobile-secret-sockets {
        display: grid;
        grid-template-columns: repeat(var(--code-length), 34px);
        gap: 8px;
        margin-top: 8px;
      }

      .mobile-secret-sockets .socket {
        width: 34px;
        height: 34px;
      }

      .palette-mobile {
        grid-template-columns: repeat(var(--palette-columns, 4), 1fr);
        gap: 8px;
      }

      .palette-mobile .tray-peg {
        min-height: 48px;
        padding: 6px;
      }

      .mobile-sticky {
        position: sticky;
        bottom: calc(8px + var(--safe-bottom));
        margin-top: 12px;
        padding: 12px;
        border-radius: 22px;
        background: linear-gradient(180deg, rgba(234, 216, 182, 0.95), rgba(215, 194, 154, 0.95));
        box-shadow: inset 0 2px 6px rgba(86, 66, 37, 0.3),
          0 12px 24px rgba(72, 56, 32, 0.18);
      }

      .mobile-action-bar {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 64px;
        gap: 12px;
        align-items: center;
      }

      .mobile-palette {
        margin-top: 0;
      }

      .mobile-submit-column {
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 64px;
        max-width: 64px;
        width: 100%;
      }

      .mobile-submit-column button {
        width: 100%;
        min-height: 44px;
        padding: 0;
      }

      .icon-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 44px;
        min-height: 44px;
        width: 56px;
        height: 56px;
        padding: 0;
        border-radius: 14px;
        border: 2px solid #5f4321;
        background: #7f5c2d;
        color: #fef7e6;
        box-shadow: 0 8px 14px rgba(77, 55, 26, 0.35),
          inset 0 2px 4px rgba(255, 255, 255, 0.35);
        cursor: pointer;
      }

      .icon-button svg {
        width: 24px;
        height: 24px;
        fill: none;
        stroke: currentColor;
        stroke-width: 3.5;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .icon-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }

      .mobile-controls {
        display: grid;
        gap: 10px;
        margin-top: 10px;
      }

      .mobile-controls button {
        padding: 12px 16px;
        border-radius: 14px;
        border: none;
        font-weight: 700;
        cursor: pointer;
        background: #7f5c2d;
        color: #fef7e6;
        box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.35),
          inset 0 -3px 5px rgba(57, 41, 19, 0.5);
      }

      .mobile-controls button.secondary {
        background: #d8c09a;
        color: #4a3b26;
      }

      .mobile-controls button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .debug-indicator {
        position: fixed;
        bottom: calc(12px + var(--safe-bottom));
        right: calc(12px + var(--safe-right));
        padding: 6px 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.7);
        color: #fef7e6;
        font-size: 0.75rem;
        z-index: 1000;
      }

      @media (max-width: 900px) {
        body {
          padding: 16px;
        }

        .board {
          min-width: 820px;
        }
      }

      @media (max-width: 768px) {
        body {
          padding: calc(16px + var(--safe-top)) calc(16px + var(--safe-right))
            calc(16px + var(--safe-bottom)) calc(16px + var(--safe-left));
        }

        .game-shell {
          justify-content: stretch;
        }

        .desktop-layout {
          display: none;
        }

        .mobile-layout {
          display: block;
        }

        .mobile-layout {
          padding-bottom: calc(170px + var(--safe-bottom));
        }

        .board {
          min-width: 0;
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .controls-panel {
          order: 2;
        }

        .board-playfield {
          order: 1;
        }
      }

      @media (max-width: 480px) {
        :root {
          --socket-size: 48px;
          --socket-gap: 10px;
          --feedback-size: 16px;
          --feedback-gap: 6px;
          --peg-size: 34px;
        }

        .board-frame {
          padding: 16px;
        }

        .attempts-area {
          grid-template-columns: 1fr;
        }

        .attempt-row {
          grid-template-columns: 1fr;
          gap: 10px;
        }

        .feedback-sockets {
          justify-content: flex-start;
        }

        .row-numbers {
          display: none;
        }

        .board-controls button {
          width: 100%;
        }
      }

      @media (max-width: 360px) {
        .mobile-layout {
          --mh-token: 30px;
          --mh-gap: 6px;
        }

        .m-history__guess {
          flex-wrap: wrap;
        }
      }

      @media (max-width: 340px) {
        .mobile-action-bar {
          grid-template-columns: 1fr;
        }

        .mobile-submit-column {
          min-width: 0;
          width: 100%;
        }
      }

      .condensed .attempt-row {
        padding: 8px 12px;
      }

      .condensed .attempt-row:not(.current) {
        --socket-size: 34px;
        --socket-gap: 8px;
        --feedback-size: 12px;
        --feedback-gap: 4px;
        --peg-size: 24px;
        opacity: 0.9;
      }

      .condensed .attempt-row.current {
        --socket-size: 50px;
        --socket-gap: 10px;
        --feedback-size: 16px;
        --feedback-gap: 6px;
        --peg-size: 36px;
      }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <section class="board-frame desktop-layout" aria-label="Logic board">
        <div class="board">
          <div class="board-playfield" id="board-playfield">
            <div class="secret-row" id="secret-row">
              <div class="secret-label">Secret Code</div>
              <div class="secret-sockets" id="secret-sockets"></div>
              <div class="secret-cover" id="secret-cover"></div>
            </div>

            <div class="attempts-area">
              <div class="attempts-grid" id="attempt-rows"></div>
              <div class="row-numbers" id="row-numbers"></div>
            </div>
          </div>

          <aside class="controls-panel">
            <div class="status-plaques">
              <div class="plaque" id="status-summary">Playing • 1 / 12 • 00</div>
            </div>

            <div class="game-config">
              <button class="secondary" id="new-game" aria-label="New Game" title="New Game">
                New
              </button>
              <div class="game-type-picker" id="game-type-picker">
                <span class="sr-only" id="game-type-label">Game Type</span>
                <button
                  type="button"
                  class="game-type-trigger"
                  id="game-type-trigger"
                  aria-labelledby="game-type-label game-type-trigger-label"
                  aria-haspopup="listbox"
                  aria-expanded="false"
                >
                  <span id="game-type-trigger-label">On</span>
                </button>
                <ul
                  class="game-type-options"
                  id="game-type-options"
                  role="listbox"
                  aria-hidden="true"
                ></ul>
              </div>
            </div>

            <div class="tray">
              <div class="tray-label">Peg Tray</div>
              <div class="palette" id="palette-desktop"></div>
            </div>

            <div class="board-controls">
              <button id="submit-guess" class="icon-button" aria-label="Submit" title="Submit" disabled>
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4.5 12.5l5 5 10-10" />
                </svg>
              </button>
              <button class="secondary" id="clear-guess">Clear Row</button>
            </div>

            <p class="board-hint">
              Select a peg color, then place it into the current row. Feedback pegs appear
              after submission (black first, then white). The secret cover opens when the
              game ends.
            </p>
          </aside>
        </div>
      </section>

      <section class="mobile-layout" aria-label="Logic mobile board">
          <div class="mobile-status">
            <div class="mobile-status-text">
              <div class="mobile-status-summary" id="mobile-status-summary">Playing • 1 / 12 • 00</div>
            </div>
          <div class="mobile-controls-row">
            <button
              class="mobile-new-game"
              id="mobile-new-game"
              aria-label="New Game"
              title="New Game"
            >
              New
            </button>
            <div class="game-type-picker" id="mobile-game-type-picker">
              <span class="sr-only" id="mobile-game-type-label">Game Type</span>
              <button
                type="button"
                class="game-type-trigger"
                id="mobile-game-type-trigger"
                aria-labelledby="mobile-game-type-label mobile-game-type-trigger-label"
                aria-haspopup="listbox"
                aria-expanded="false"
              >
                <span id="mobile-game-type-trigger-label">On</span>
              </button>
              <ul
                class="game-type-options"
                id="mobile-game-type-options"
                role="listbox"
                aria-hidden="true"
              ></ul>
            </div>
          </div>
        </div>

        <div class="mobile-secret" id="mobile-secret">
          <div class="mobile-secret-label">Secret Code</div>
          <div class="mobile-secret-sockets" id="mobile-secret-sockets"></div>
        </div>

        <div class="mobile-current">
          <div class="mobile-current-row" id="mobile-current-row"></div>
        </div>

        <div class="mobile-history">
          <div class="mobile-history-list" id="mobile-history-list"></div>
        </div>

        <div class="mobile-sticky">
          <div class="mobile-action-bar">
            <div class="mobile-palette">
              <div class="palette palette-mobile" id="palette-mobile"></div>
            </div>
            <div class="mobile-submit-column">
              <button
                id="mobile-submit-guess"
                class="icon-button"
                aria-label="Submit"
                title="Submit"
                disabled
              >
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M4.5 12.5l5 5 10-10" />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </section>
    </main>

    <div id="debug-indicator" class="debug-indicator" hidden></div>

    <div id="status-live" class="sr-only" aria-live="polite"></div>

    <script>
      /*
        Mobile QA:
        - Open ?debug=1 to show viewport/scroll diagnostics and input logging.
        - Test at 390x844, 360x740, 844x390 to ensure no horizontal scroll.
        - Verify tap-to-place works end-to-end, submit is reachable, and history scrolls.
      */
      const BASE_COLORS = [
        { id: 0, name: "Color 1", hex: "#ef4444" },
        { id: 1, name: "Color 2", hex: "#f97316" },
        { id: 2, name: "Color 3", hex: "#facc15" },
        { id: 3, name: "Color 4", hex: "#22c55e" },
        { id: 4, name: "Color 5", hex: "#14b8a6" },
        { id: 5, name: "Color 6", hex: "#3b82f6" },
        { id: 6, name: "Color 7", hex: "#8b5cf6" },
        { id: 7, name: "Color 8", hex: "#ec4899" },
      ];

      const GAME_TYPES = [
        {
          id: "L4_C6_R0",
          label: "4 / 6 — No repeats",
          codeLength: 4,
          paletteSize: 6,
          repeatsAllowed: false,
          maxAttempts: 6,
        },
        {
          id: "L4_C6_R1",
          label: "4 / 6 — Repeats allowed",
          codeLength: 4,
          paletteSize: 6,
          repeatsAllowed: true,
          maxAttempts: 6,
        },
        {
          id: "L5_C8_R0",
          label: "5 / 8 — No repeats",
          codeLength: 5,
          paletteSize: 8,
          repeatsAllowed: false,
          maxAttempts: 12,
        },
        {
          id: "L5_C8_R1",
          label: "5 / 8 — Repeats allowed",
          codeLength: 5,
          paletteSize: 8,
          repeatsAllowed: true,
          maxAttempts: 12,
        },
      ];

      const MOBILE_BREAKPOINT = 768;
      const DEBUG_UI = window.location.search.includes("debug=1");
      const GAME_TYPE_STORAGE_KEY = "logic.gameType";
      const DEFAULT_GAME_TYPE_ID = "L5_C8_R1";

      const state = {
        secretCode: [],
        attempts: [],
        currentGuess: [],
        status: "playing",
        gameStartTsMs: 0,
        gameEndTsMs: null,
        elapsedSec: 0,
      };

      let selectedColorId = null;
      let activeGameType =
        GAME_TYPES.find((type) => type.id === DEFAULT_GAME_TYPE_ID) || GAME_TYPES[0];
      let timerIntervalId = null;

      const attemptRowsEl = document.getElementById("attempt-rows");
      const paletteDesktopEl = document.getElementById("palette-desktop");
      const paletteMobileEl = document.getElementById("palette-mobile");
      const secretSocketsEl = document.getElementById("secret-sockets");
      const secretRowEl = document.getElementById("secret-row");
      const statusSummaryEl = document.getElementById("status-summary");
      const submitBtn = document.getElementById("submit-guess");
      const clearBtn = document.getElementById("clear-guess");
      const newGameBtn = document.getElementById("new-game");
      const gameTypePickerEl = document.getElementById("game-type-picker");
      const gameTypeTriggerEl = document.getElementById("game-type-trigger");
      const gameTypeTriggerLabelEl = document.getElementById("game-type-trigger-label");
      const gameTypeOptionsEl = document.getElementById("game-type-options");
      const mobileStatusSummaryEl = document.getElementById("mobile-status-summary");
      const mobileNewGameBtn = document.getElementById("mobile-new-game");
      const mobileGameTypePickerEl = document.getElementById("mobile-game-type-picker");
      const mobileGameTypeTriggerEl = document.getElementById("mobile-game-type-trigger");
      const mobileGameTypeTriggerLabelEl = document.getElementById("mobile-game-type-trigger-label");
      const mobileGameTypeOptionsEl = document.getElementById("mobile-game-type-options");
      const mobileSubmitBtn = document.getElementById("mobile-submit-guess");
      const mobileCurrentRowEl = document.getElementById("mobile-current-row");
      const mobileHistoryListEl = document.getElementById("mobile-history-list");
      const mobileSecretEl = document.getElementById("mobile-secret");
      const mobileSecretSocketsEl = document.getElementById("mobile-secret-sockets");
      const rowNumbersEl = document.getElementById("row-numbers");
      const statusLiveEl = document.getElementById("status-live");
      const boardPlayfieldEl = document.getElementById("board-playfield");
      const boardFrameEl = document.querySelector(".board-frame");
      const debugIndicatorEl = document.getElementById("debug-indicator");

      function getGameTypeById(gameTypeId) {
        return GAME_TYPES.find((type) => type.id === gameTypeId) || null;
      }

      function getActiveColors() {
        return BASE_COLORS.slice(0, activeGameType.paletteSize);
      }

      function getActiveColorIds() {
        return getActiveColors().map((color) => color.id);
      }

      function shuffleArray(items) {
        const copy = items.slice();
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      }

      function generateSecretCode() {
        const colorIds = getActiveColorIds();
        const { codeLength, repeatsAllowed } = activeGameType;
        if (repeatsAllowed) {
          return Array.from({ length: codeLength }, () =>
            colorIds[Math.floor(Math.random() * colorIds.length)]
          );
        }
        return shuffleArray(colorIds).slice(0, codeLength);
      }

      function evaluateGuess(code, guess) {
        // Feedback algorithm with duplicate handling:
        // First count black pegs and mark used positions,
        // then count whites using remaining occurrences in the code.
        let black = 0;
        const codeLength = code.length;
        const codeUsed = Array(codeLength).fill(false);
        const guessUsed = Array(codeLength).fill(false);

        for (let i = 0; i < codeLength; i += 1) {
          if (code[i] === guess[i]) {
            black += 1;
            codeUsed[i] = true;
            guessUsed[i] = true;
          }
        }

        const remainingCounts = Array(activeGameType.paletteSize).fill(0);
        for (let i = 0; i < codeLength; i += 1) {
          if (!codeUsed[i]) {
            remainingCounts[code[i]] += 1;
          }
        }

        let white = 0;
        for (let i = 0; i < codeLength; i += 1) {
          if (guessUsed[i]) {
            continue;
          }
          const color = guess[i];
          if (remainingCounts[color] > 0) {
            white += 1;
            remainingCounts[color] -= 1;
          }
        }

        return { black, white };
      }

      function runFeedbackTests() {
        // Test cases for feedback correctness, including duplicates.
        console.info("Running feedback tests...");
        console.info(
          "All correct:",
          evaluateGuess([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])
        );
        console.info(
          "No matches:",
          evaluateGuess([0, 1, 2, 3, 4], [5, 6, 7, 5, 6])
        );
        console.info(
          "All misplaced:",
          evaluateGuess([0, 1, 2, 3, 4], [1, 2, 3, 4, 0])
        );
        console.info(
          "Duplicate limitation:",
          evaluateGuess([0, 0, 1, 2, 3], [0, 0, 0, 0, 0])
        );
        console.info(
          "Mixed duplicates:",
          evaluateGuess([0, 1, 1, 2, 2], [1, 1, 0, 2, 3])
        );
      }

      function updateLayoutVariables() {
        document.documentElement.style.setProperty("--code-length", activeGameType.codeLength);
        const feedbackColumns = activeGameType.codeLength <= 4 ? 2 : 3;
        const feedbackRows = Math.ceil(activeGameType.codeLength / feedbackColumns);
        document.documentElement.style.setProperty("--feedback-columns", feedbackColumns);
        document.documentElement.style.setProperty("--feedback-rows", feedbackRows);
        const paletteColumns = activeGameType.paletteSize === 6 ? 3 : 4;
        document.documentElement.style.setProperty("--palette-columns", paletteColumns);
        document.documentElement.style.setProperty("--max-attempts", activeGameType.maxAttempts);
      }

      const gameTypePickers = [
        {
          container: gameTypePickerEl,
          trigger: gameTypeTriggerEl,
          label: gameTypeTriggerLabelEl,
          options: gameTypeOptionsEl,
        },
        {
          container: mobileGameTypePickerEl,
          trigger: mobileGameTypeTriggerEl,
          label: mobileGameTypeTriggerLabelEl,
          options: mobileGameTypeOptionsEl,
        },
      ];

      function formatCompactGameTypeLabel(type) {
        return type.repeatsAllowed ? "On" : "Off";
      }

      function setGameTypePickerOpen(picker, shouldOpen) {
        picker.trigger.setAttribute("aria-expanded", shouldOpen.toString());
        picker.options.setAttribute("aria-hidden", (!shouldOpen).toString());
        if (shouldOpen) {
          const selectedOption = picker.options.querySelector(
            `[data-game-type-id="${activeGameType.id}"]`
          );
          const focusTarget = selectedOption || picker.options.querySelector(".game-type-option");
          if (focusTarget) {
            focusTarget.focus();
          }
        }
      }

      function closeAllGameTypePickers() {
        gameTypePickers.forEach((picker) => {
          if (!picker.trigger || !picker.options) {
            return;
          }
          setGameTypePickerOpen(picker, false);
        });
      }

      function syncGameTypePickers(gameTypeId) {
        const selectedType = getGameTypeById(gameTypeId);
        if (!selectedType) {
          return;
        }
        gameTypePickers.forEach((picker) => {
          if (!picker.trigger || !picker.label || !picker.options) {
            return;
          }
          picker.label.textContent = formatCompactGameTypeLabel(selectedType);
          picker.options.querySelectorAll(".game-type-option").forEach((optionEl) => {
            const isSelected = optionEl.dataset.gameTypeId === gameTypeId;
            optionEl.setAttribute("aria-selected", isSelected.toString());
            optionEl.tabIndex = isSelected ? 0 : -1;
          });
        });
      }

      function applyGameType(gameTypeId, { startNewGame: shouldStartNewGame = true, persist = true } = {}) {
        const nextType = getGameTypeById(gameTypeId);
        if (!nextType) {
          return;
        }
        activeGameType = nextType;
        updateLayoutVariables();
        renderRowNumbers();
        syncGameTypePickers(gameTypeId);
        if (persist) {
          localStorage.setItem(GAME_TYPE_STORAGE_KEY, gameTypeId);
        }
        if (shouldStartNewGame) {
          startNewGame();
          updateResponsiveLayout();
        }
      }

      function buildGameTypeOptions(optionsEl) {
        if (!optionsEl) {
          return;
        }
        optionsEl.innerHTML = "";
        GAME_TYPES.forEach((type) => {
          const option = document.createElement("button");
          option.type = "button";
          option.className = "game-type-option";
          option.setAttribute("role", "option");
          option.setAttribute("aria-selected", "false");
          option.dataset.gameTypeId = type.id;
          option.textContent = type.label;
          optionsEl.appendChild(option);
        });
      }

      function initializeGameTypes() {
        buildGameTypeOptions(gameTypeOptionsEl);
        buildGameTypeOptions(mobileGameTypeOptionsEl);
        const storedGameTypeId = localStorage.getItem(GAME_TYPE_STORAGE_KEY);
        const initialGameTypeId = getGameTypeById(storedGameTypeId)
          ? storedGameTypeId
          : DEFAULT_GAME_TYPE_ID;
        applyGameType(initialGameTypeId, {
          startNewGame: false,
          persist: !getGameTypeById(storedGameTypeId),
        });
      }

      function createPeg(colorHex, sizeClass) {
        const peg = document.createElement("div");
        peg.className = `peg ${sizeClass}`;
        peg.style.background = colorHex;
        return peg;
      }

      function createSocket(sizeClass, label, interactive = false) {
        const socket = document.createElement("div");
        socket.className = `socket ${sizeClass}`;
        socket.setAttribute("aria-label", label);
        if (interactive) {
          socket.classList.add("interactive");
          if (selectedColorId !== null) {
            socket.classList.add("ready");
          }
          socket.setAttribute("role", "button");
          socket.tabIndex = 0;
        }
        return socket;
      }

      function debugLog(message, payload = "") {
        if (DEBUG_UI) {
          if (payload !== "") {
            console.info(message, payload);
          } else {
            console.info(message);
          }
        }
      }

      function formatElapsedTime(elapsedSec) {
        if (elapsedSec < 60) {
          return String(elapsedSec).padStart(2, "0");
        }
        const seconds = elapsedSec % 60;
        const minutesTotal = Math.floor(elapsedSec / 60);
        if (elapsedSec < 3600) {
          return `${String(minutesTotal).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        }
        const hours = Math.floor(minutesTotal / 60);
        const minutes = minutesTotal % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(
          seconds
        ).padStart(2, "0")}`;
      }

      function updateElapsedTime() {
        if (state.status === "playing") {
          state.elapsedSec = Math.floor((Date.now() - state.gameStartTsMs) / 1000);
        } else if (state.gameEndTsMs !== null) {
          state.elapsedSec = Math.floor((state.gameEndTsMs - state.gameStartTsMs) / 1000);
        }
      }

      function stopGameTimer() {
        if (timerIntervalId !== null) {
          clearInterval(timerIntervalId);
          timerIntervalId = null;
        }
      }

      function startGameTimer() {
        stopGameTimer();
        state.gameStartTsMs = Date.now();
        state.gameEndTsMs = null;
        state.elapsedSec = 0;
        timerIntervalId = setInterval(() => {
          if (state.status !== "playing") {
            stopGameTimer();
            return;
          }
          updateElapsedTime();
          updateStatus();
        }, 1000);
      }

      function renderSecretCode() {
        secretSocketsEl.innerHTML = "";
        for (let i = 0; i < activeGameType.codeLength; i += 1) {
          const socket = createSocket("large", `Secret position ${i + 1}`);
          if (state.status !== "playing") {
            const colorId = state.secretCode[i];
            socket.appendChild(createPeg(BASE_COLORS[colorId].hex, "large"));
          }
          secretSocketsEl.appendChild(socket);
        }
        if (state.status === "playing") {
          secretRowEl.classList.remove("revealed");
        } else {
          secretRowEl.classList.add("revealed");
        }
      }

      function renderMobileSecretCode() {
        mobileSecretSocketsEl.innerHTML = "";
        for (let i = 0; i < activeGameType.codeLength; i += 1) {
          const socket = createSocket("large", `Secret position ${i + 1}`);
          if (state.status !== "playing") {
            const colorId = state.secretCode[i];
            socket.appendChild(createPeg(BASE_COLORS[colorId].hex, "large"));
          }
          mobileSecretSocketsEl.appendChild(socket);
        }

        if (state.status === "playing") {
          mobileSecretEl.classList.remove("revealed");
        } else {
          mobileSecretEl.classList.add("revealed");
        }
      }

      function renderRowNumbers() {
        rowNumbersEl.innerHTML = "";
        for (let i = 1; i <= activeGameType.maxAttempts; i += 1) {
          const number = document.createElement("div");
          number.className = "row-number";
          number.textContent = i;
          rowNumbersEl.appendChild(number);
        }
      }

      function isColorUsed(colorId, ignorePosition = null) {
        return state.currentGuess.some(
          (guessColor, index) => guessColor === colorId && index !== ignorePosition
        );
      }

      function setCurrentGuessAt(position, colorId) {
        if (state.status !== "playing") {
          return;
        }
        if (
          colorId !== null &&
          !activeGameType.repeatsAllowed &&
          isColorUsed(colorId, position)
        ) {
          return;
        }
        state.currentGuess[position] = colorId;
      }

      function handleSocketPlacement(position) {
        if (selectedColorId === null) {
          setCurrentGuessAt(position, null);
        } else {
          setCurrentGuessAt(position, selectedColorId);
        }
        debugLog("Socket tapped", { position, selectedColorId });
        renderAll();
        updateStatus();
      }

      function renderAttempts() {
        attemptRowsEl.innerHTML = "";
        const currentRowIndex = state.attempts.length;
        const allowDrag = !isTouchLayout();

        for (let rowIndex = 0; rowIndex < activeGameType.maxAttempts; rowIndex += 1) {
          const row = document.createElement("div");
          row.className = "attempt-row";
          if (state.status === "playing" && rowIndex === currentRowIndex) {
            row.classList.add("current");
          }

          const guessSockets = document.createElement("div");
          guessSockets.className = "guess-sockets";

          let guessValues = Array(activeGameType.codeLength).fill(null);
          if (rowIndex < state.attempts.length) {
            guessValues = state.attempts[rowIndex].guess;
          } else if (rowIndex === currentRowIndex && state.status === "playing") {
            guessValues = state.currentGuess;
          }

          guessValues.forEach((colorId, position) => {
            const label = `Attempt ${rowIndex + 1}, position ${position + 1} socket`;
            const interactive =
              state.status === "playing" && rowIndex === currentRowIndex;
            const socket = createSocket("large", label, interactive);

            if (colorId !== null) {
              socket.appendChild(createPeg(BASE_COLORS[colorId].hex, "large"));
            }

            if (interactive) {
              socket.addEventListener("click", () => handleSocketPlacement(position));
              socket.addEventListener("keydown", (event) => {
                if (event.key === "Enter" || event.key === " ") {
                  event.preventDefault();
                  handleSocketPlacement(position);
                }
              });
              if (allowDrag) {
                socket.addEventListener("dragover", (event) => {
                  event.preventDefault();
                });
                socket.addEventListener("drop", (event) => {
                  event.preventDefault();
                  const colorIdText = event.dataTransfer.getData("text/plain");
                  if (colorIdText !== "") {
                    selectedColorId = Number(colorIdText);
                    setCurrentGuessAt(position, selectedColorId);
                    renderAll();
                    updateStatus();
                  }
                });
              }
            }

            guessSockets.appendChild(socket);
          });

          const feedbackSockets = document.createElement("div");
          feedbackSockets.className = "feedback-sockets";
          let feedback = { black: 0, white: 0 };
          if (rowIndex < state.attempts.length) {
            feedback = state.attempts[rowIndex];
          }

          const feedbackPegs = [
            ...Array(feedback.black).fill("black"),
            ...Array(feedback.white).fill("white"),
            ...Array(activeGameType.codeLength - feedback.black - feedback.white).fill("empty"),
          ];

          feedbackPegs.forEach((type, index) => {
            const socket = createSocket(
              "small",
              `Attempt ${rowIndex + 1}, feedback socket ${index + 1}`
            );
            if (type === "black") {
              const peg = document.createElement("div");
              peg.className = "peg small black";
              socket.appendChild(peg);
            } else if (type === "white") {
              const peg = document.createElement("div");
              peg.className = "peg small white";
              socket.appendChild(peg);
            }
            feedbackSockets.appendChild(socket);
          });

          row.appendChild(guessSockets);
          row.appendChild(feedbackSockets);
          attemptRowsEl.appendChild(row);
        }
      }

      function renderMobileCurrentRow() {
        mobileCurrentRowEl.innerHTML = "";
        const row = document.createElement("div");
        row.className = "m-history__row m-history__row--current";

        const guess = document.createElement("div");
        guess.className = "m-history__guess";

        state.currentGuess.forEach((colorId, position) => {
          const token = document.createElement("div");
          token.className = "m-history__token";
          token.setAttribute(
            "aria-label",
            `Current attempt, position ${position + 1} token`
          );

          if (colorId !== null) {
            token.style.backgroundColor = BASE_COLORS[colorId].hex;
          } else {
            token.classList.add("m-history__token--empty");
          }

          if (state.status === "playing") {
            token.classList.add("m-history__token--interactive");
            if (selectedColorId !== null) {
              token.classList.add("m-history__token--ready");
            }
            token.setAttribute("role", "button");
            token.tabIndex = 0;
            token.addEventListener("click", () => handleSocketPlacement(position));
            token.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                handleSocketPlacement(position);
              }
            });
          }

          guess.appendChild(token);
        });

        const feedback = document.createElement("div");
        feedback.className = "m-history__feedback m-history__feedback--placeholder";
        feedback.setAttribute("aria-hidden", "true");

        row.appendChild(guess);
        row.appendChild(feedback);
        mobileCurrentRowEl.appendChild(row);
      }

      function renderMobileHistory() {
        mobileHistoryListEl.innerHTML = "";
        if (state.attempts.length === 0) {
          return;
        }

        state.attempts.forEach((attempt, index) => {
          const row = document.createElement("div");
          row.className = "m-history__row";

          const guess = document.createElement("div");
          guess.className = "m-history__guess";
          attempt.guess.forEach((colorId, position) => {
            const token = document.createElement("div");
            token.className = "m-history__token";
            token.setAttribute(
              "aria-label",
              `Attempt ${index + 1}, position ${position + 1} token`
            );
            if (colorId !== null) {
              token.style.backgroundColor = BASE_COLORS[colorId].hex;
            } else {
              token.classList.add("m-history__token--empty");
            }
            guess.appendChild(token);
          });

          const feedback = document.createElement("div");
          feedback.className = "m-history__feedback";
          const feedbackPegs = [
            ...Array(attempt.black).fill("black"),
            ...Array(attempt.white).fill("white"),
          ];
          feedbackPegs.forEach((type, pegIndex) => {
            const peg = document.createElement("div");
            peg.className = `m-history__peg m-history__peg--${type}`;
            peg.setAttribute(
              "aria-label",
              `Attempt ${index + 1}, ${type} feedback peg ${pegIndex + 1}`
            );
            feedback.appendChild(peg);
          });

          row.appendChild(guess);
          row.appendChild(feedback);
          mobileHistoryListEl.appendChild(row);
        });
      }

      function renderPalette(targetEl) {
        targetEl.innerHTML = "";
        const allowDrag = !isTouchLayout();
        getActiveColors().forEach((color) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "tray-peg";
          button.setAttribute("aria-label", color.name);
          button.title = color.name;
          const colorUsed = !activeGameType.repeatsAllowed && isColorUsed(color.id);
          button.disabled =
            state.status !== "playing" || (colorUsed && selectedColorId !== color.id);
          button.draggable = state.status === "playing" && allowDrag;
          if (selectedColorId === color.id) {
            button.classList.add("selected");
          }

          const peg = createPeg(color.hex, "large");
          button.appendChild(peg);

          button.addEventListener("click", () => {
            if (selectedColorId === color.id) {
              selectedColorId = null;
            } else {
              selectedColorId = color.id;
            }
            debugLog("Palette selected", { colorId: selectedColorId });
            renderAll();
            updateStatus();
          });

          button.addEventListener("dragstart", (event) => {
            if (allowDrag) {
              event.dataTransfer.setData("text/plain", color.id.toString());
            }
          });

          targetEl.appendChild(button);
        });
      }

      function renderPalettes() {
        renderPalette(paletteDesktopEl);
        renderPalette(paletteMobileEl);
      }

      function renderAll() {
        renderAttempts();
        renderMobileCurrentRow();
        renderMobileHistory();
        renderSecretCode();
        renderMobileSecretCode();
        renderPalettes();
      }

      function updateStatus() {
        updateElapsedTime();
        const attemptNumber =
          state.status === "playing" ? state.attempts.length + 1 : state.attempts.length;
        const statusLabel = `${state.status.charAt(0).toUpperCase()}${state.status.slice(1)}`;
        const summaryText = `${statusLabel} • ${attemptNumber} / ${activeGameType.maxAttempts} • ${formatElapsedTime(
          state.elapsedSec
        )}`;
        statusSummaryEl.textContent = summaryText;
        mobileStatusSummaryEl.textContent = summaryText;
        submitBtn.disabled =
          state.status !== "playing" || state.currentGuess.some((slot) => slot === null);
        clearBtn.disabled = state.status !== "playing";
        mobileSubmitBtn.disabled =
          state.status !== "playing" || state.currentGuess.some((slot) => slot === null);

        statusLiveEl.textContent =
          state.status === "playing"
            ? `Attempt ${attemptNumber}.`
            : `Game ${state.status}.`;
      }

      function clearGuess() {
        state.currentGuess = Array(activeGameType.codeLength).fill(null);
        renderAll();
        updateStatus();
      }

      function submitGuess() {
        if (state.status !== "playing") {
          return;
        }
        if (state.currentGuess.some((slot) => slot === null)) {
          return;
        }

        const guess = state.currentGuess.slice();
        const result = evaluateGuess(state.secretCode, guess);
        state.attempts.push({ guess, black: result.black, white: result.white });

        statusLiveEl.textContent = `Black ${result.black}, White ${result.white}.`;

        if (result.black === activeGameType.codeLength) {
          state.status = "won";
        } else if (state.attempts.length >= activeGameType.maxAttempts) {
          state.status = "lost";
        }
        if (state.status !== "playing") {
          state.gameEndTsMs = Date.now();
          updateElapsedTime();
          stopGameTimer();
        }

        state.currentGuess = Array(activeGameType.codeLength).fill(null);
        renderAll();
        updateStatus();
      }

      function startNewGame() {
        // State handling for a new game.
        state.secretCode = generateSecretCode();
        state.attempts = [];
        state.currentGuess = Array(activeGameType.codeLength).fill(null);
        state.status = "playing";
        selectedColorId = null;
        startGameTimer();
        renderAll();
        updateStatus();
      }

      function isTouchLayout() {
        return window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT}px)`).matches;
      }

      function updateDebugIndicator() {
        if (!DEBUG_UI) {
          debugIndicatorEl.hidden = true;
          return;
        }
        const scrollWidth = document.documentElement.scrollWidth;
        const viewportWidth = window.innerWidth;
        const overflow = scrollWidth > viewportWidth;
        debugIndicatorEl.hidden = false;
        debugIndicatorEl.textContent = `vw ${viewportWidth}px | sw ${scrollWidth}px | overflow ${overflow}`;
      }

      function updateResponsiveLayout() {
        if (isTouchLayout()) {
          document.documentElement.style.setProperty("--board-scale", "1");
          document.body.classList.remove("condensed");
          renderAll();
          updateDebugIndicator();
          return;
        }
        const availableWidth = boardFrameEl.clientWidth - 16;
        const playfieldWidth = boardPlayfieldEl.scrollWidth;
        const scale = Math.min(1, availableWidth / playfieldWidth);
        document.documentElement.style.setProperty("--board-scale", scale.toFixed(3));

        const minTapTarget = 40;
        const socketBaseSize = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue("--socket-size")
        );
        const effectiveSize = socketBaseSize * scale;
        const shouldCondense = effectiveSize < minTapTarget;
        const hadCondensed = document.body.classList.contains("condensed");
        document.body.classList.toggle("condensed", shouldCondense);

        if (shouldCondense !== hadCondensed) {
          requestAnimationFrame(updateResponsiveLayout);
          return;
        }

        renderAll();
        updateDebugIndicator();
      }

      function getGameTypeOptions(picker) {
        return Array.from(picker.options.querySelectorAll(".game-type-option"));
      }

      function focusGameTypeOption(picker, index) {
        const options = getGameTypeOptions(picker);
        if (options.length === 0) {
          return;
        }
        const clampedIndex = Math.min(options.length - 1, Math.max(0, index));
        options[clampedIndex].focus();
      }

      function handleGameTypeOptionSelection(picker, gameTypeId) {
        applyGameType(gameTypeId);
        closeAllGameTypePickers();
        picker.trigger.focus();
      }

      function bindGameTypePickerEvents(picker) {
        if (!picker.trigger || !picker.options || !picker.container) {
          return;
        }

        picker.trigger.addEventListener("click", () => {
          const isOpen = picker.trigger.getAttribute("aria-expanded") === "true";
          closeAllGameTypePickers();
          setGameTypePickerOpen(picker, !isOpen);
        });

        picker.trigger.addEventListener("keydown", (event) => {
          if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            closeAllGameTypePickers();
            setGameTypePickerOpen(picker, true);
          }
        });

        picker.options.addEventListener("click", (event) => {
          const option = event.target.closest(".game-type-option");
          if (!option) {
            return;
          }
          handleGameTypeOptionSelection(picker, option.dataset.gameTypeId);
        });

        picker.options.addEventListener("keydown", (event) => {
          const options = getGameTypeOptions(picker);
          const currentIndex = options.indexOf(document.activeElement);
          if (event.key === "ArrowDown") {
            event.preventDefault();
            focusGameTypeOption(picker, currentIndex + 1);
          } else if (event.key === "ArrowUp") {
            event.preventDefault();
            focusGameTypeOption(picker, currentIndex - 1);
          } else if (event.key === "Home") {
            event.preventDefault();
            focusGameTypeOption(picker, 0);
          } else if (event.key === "End") {
            event.preventDefault();
            focusGameTypeOption(picker, options.length - 1);
          } else if (event.key === "Escape") {
            event.preventDefault();
            closeAllGameTypePickers();
            picker.trigger.focus();
          } else if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            const option = document.activeElement;
            if (option && option.classList.contains("game-type-option")) {
              handleGameTypeOptionSelection(picker, option.dataset.gameTypeId);
            }
          }
        });
      }

      submitBtn.addEventListener("click", submitGuess);
      clearBtn.addEventListener("click", clearGuess);
      newGameBtn.addEventListener("click", startNewGame);
      mobileSubmitBtn.addEventListener("click", submitGuess);
      mobileNewGameBtn.addEventListener("click", startNewGame);
      gameTypePickers.forEach((picker) => bindGameTypePickerEvents(picker));
      document.addEventListener("click", (event) => {
        const isInsidePicker = gameTypePickers.some(
          (picker) => picker.container && picker.container.contains(event.target)
        );
        if (!isInsidePicker) {
          closeAllGameTypePickers();
        }
      });
      window.addEventListener("resize", updateResponsiveLayout);
      window.addEventListener("orientationchange", updateResponsiveLayout);

      runFeedbackTests();
      renderRowNumbers();
      initializeGameTypes();
      startNewGame();
      updateResponsiveLayout();
      updateDebugIndicator();
    </script>
  </body>
</html>
